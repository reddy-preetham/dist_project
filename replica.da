
NOPS=100
import sys
import time
import random
from crypto_utils import *
from utils import *
# from block_tree import BlockTree
from leader_election import LeaderElection
# from pacemaker import Pacemaker
# from safety import Safety


# name=""
# public_keys=[]
# private_key=""
# f=3
config(channel = 'reliable')

class Replica(process):

    def setup(replica_id:str,replicas_ids:set,client_ids:dict,private_key:str,public_key:str,replica_public_keys:dict,client_public_keys:dict,n_faulty_replicas:int):
        self.n_replicas=len(replicas_ids)
        self.run_done = False
        self.window_size=5
        self.network_delta=1
        del replicas_ids[replica_id]
        self.set_variables()
        
    def set_variables():
        Config.replica_id = replica_id
        Config.n_replicas = n_replicas
        Config.n_faulty_replicas = n_faulty_replicas
        Config.window_size = self.window_size
        Config.network_delta = self.network_delta
        Config.public_key=public_key
        Config.private_key=private_key
    def run():
        debug('### start')
        run_done = False
        while not run_done:
            # round_done = False
            # timer_duration = Pacemaker.get_round_timer(Pacemaker.current_round)
            # if await(round_done): pass
            # elif timeout(timer_duration): 
            #     Pacemaker.local_timeout_round()
            
            await(run_done)
        output('terminating')
        
    def receive(msg=("done",)):
        run_done=True

    # def receive(msg= ('request', p,client_id,m)):
    #     m=verify_decode(m,client_public_keys[client_id])
    #     print(("received request from",p,m))
    #     Temp.a=2

    #     # print(("dsd",Temp2.get()))
    #     send(("response",self,replica_id,sign(m,private_key)),to=p)
    #     debug('### request', p)

    def receive(msg=("request",p,client_id,m)):
        m=verify_decode(m,client_public_keys[client_id])
        print(("received request from",p,m))
        MemPool.push_transaction(m)

    def send_response(txn_id,m):
        client_id=txn_id[:txn_id.index('-')]
        send(("response",self,replica_id,sign(m,private_key)),to=client_ids[client_id])
    
    def send_msg_replica(id,msg_type,m):
        send((msg_type,self,replica_id,sign(m,private_key)),to=replica_ids[id])

    def broadcast_msg(msg_type,m):
        send((msg_type,self,replica_id,sign(m,private_key)),to=set(replica_ids.values()))

    
    def receive(msg=(msg_type,p,id,m)):
        if msg_type=="request":
            m=verify_decode(m,client_public_keys[id])
            print(("received request from",p,m))
            MemPool.push_transaction(m)
        elif msg_type=="local_timeout":
            m=verify_decode(m,replica_public_keys[id])
            Pacemaker.local_timeout_round()
        elif msg_type=="proposal_message":
            m=verify_decode(m,replica_public_keys[id])
            process_proposal_msg(m)
        elif msg_type=="vote_message":
            m=verify_decode(m,replica_public_keys[id])
            process_vote_msg(m)
        elif msg_type=="timeout_message":
            m=verify_decode(m,replica_public_keys[id])
            process_timeout_message(m)

    def process_certificate_qc(qc):
        BlockTree.process_qc(qc)
        LeaderElection.update_leaders(qc)
        Pacemaker.advance_round_qc(qc)

    def process_proposal_msg(P):
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        Pacemaker.advance_round_tc(P.last_round_tc)
        round = Pacemaker.current_round
        leader = LeaderElection.get_leader(round)
        if P.block.round != round or P.sender != leader or P.block.author != leader:
            return 
        BlockTree.execute_and_insert(P)
        vote_msg = Safety.make_vote(P.block, P.last_round_tc)
        if vote_msg != None:
            send_msg_replica(LeaderElection.get_leader(round + 1),"vote_message",vote_msg)
           

    def process_timeout_msg(M):
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        Pacemaker.advance_round_tc(M.last_round_tc)
        tc = Pacemaker.process_remote_timeout(M)
        if tc != None:
            Pacemaker.advance_round_tc(tc)
            Pacemaker.new_round_event(tc)

    
    def process_vote_msg(M):
        qc = BlockTree.process_vote(M)
        if qc!=None:
            process_certificate_qc(qc)
            process_new_round_event(None)

    def process_new_round_event(last_tc):
        if replica_id==LeaderElection.get_leader(Pacemaker.current_round):
            b=BlockTree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
            broadcast_msg("proposal_message",ProposalMsg(b,last_tc,BlockTree.high_commit_qc) )

from cacheout import Cache
from collections import deque
class MemPool:
    transaction_queue=deque()
    pending_transaction=set()
    queue_cntr:int
    req_cache=Cache() 
    def __init__(self):
        pass
    @classmethod
    def get_transactions(cls):
        txn = cls.transaction_queue.popleft()
        txn_id=txn[:txn.index(':')]
        cls.req_cache.add(txn_id,"processing")
        return [txn]

    @classmethod
    def push_transaction(cls,txn):
        txn_id = txn[:txn.index(':')]
        if(not cls.req_cache.has(txn_id)):
            cls.pending_transaction.add(txn_id)
            cls.transaction_queue.append(txn)
            cls.req_cache.add(txn_id,"In queue, not processed")
        else:
            Replica.send_response(txn_id,cls.req_cache.get(txn_id,default=None))

    @classmethod
    def processed_txns(cls,txns):
        for txn in txns:
            txn_id=txn[:txn.index(':')]
            cls.req_cache.set(txn_id,"processed")
            cls.pending_transaction.discard(txn_id)
            Replica.send_response(txn_id,cls.req_cache.get(txn_id,default=None))


        
        
