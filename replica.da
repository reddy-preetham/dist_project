# from main import *
NOPS=100
import sys
import time
import random
from crypto_utils import *

from temp import Temp
from temp2 import Temp2

# name=""
# public_keys=[]
# private_key=""
# f=3
config(channel = 'reliable')

class Replica(process):

    def setup(replica_id:int,replicas:set,client_ids:dict,private_key:str,public_key:str,replica_public_keys:dict,client_public_keys:dict,n_faulty_replicas:int):
        self.num_validators=len(replicas)
        self.run_done = False
        self.window_size=5
        

    def run():
        debug('### start')
        run_done = False
        while not run_done:
            # round_done = False
            # timer_duration = Pacemaker.get_round_timer(Pacemaker.current_round)
            # if await(round_done): pass
            # elif timeout(timer_duration): 
            #     Pacemaker.local_timeout_round()
            
            await(run_done)
        output('terminating')
        
    def receive(msg=("done",)):
        run_done=True
    def receive(msg= ('request', p,client_id,m)):
        m=verify_decode(m,client_public_keys[client_id])
        print(("received request from",p,m))
        Temp.a=2

        # print(("dsd",Temp2.get()))
        send(("response",self,replica_id,sign(m,private_key)),to=p)
        debug('### request', p)

    def send_response(txn_id,m):
        client_id=txn_id[:txn_id.index('-')]
        send(("response",self,Replica.replica_id,sign(m,private_key)),to=client_ids[client_id])

        
