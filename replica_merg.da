
NOPS=100
import sys
import time
import random

from timeout import TC,TimeoutInfo,TimeoutMsg,ProposalMsg
# from block_tree import BlockTree
# from leader_election import LeaderElection
# from pacemaker import Pacemaker
# from safety import Safety
# from block_tree import BlockTree
# from safety import Safety
from ledger import Ledger
from utils import *
import utils
from block import *
from cacheout import Cache
from collections import deque

import math
import random

# name=""
# public_keys=[]
# private_key=""
# f=3
config(channel = 'reliable')

class Replica(process):

    def setup(replica_id:str,replicas_ids:dict,client_ids:dict,private_key:str,public_key:str,replica_public_keys:dict,client_public_keys:dict,n_faulty_replicas:int):
        self.n_replicas=len(replicas_ids)
        self.run_done = False
        self.round_done=False
        
        self.network_delta=0.25
        # del replicas_ids[replica_id]
        #=====Pacemaker Variables=====
        self.current_round=0
        self.last_round_tc=None
        self.pending_timeouts={}

        #======Mempool Variables======
        self.transaction_queue=deque()
        self.pending_transaction=set()
        self.req_cache=Cache() 

        #========Leader Election============
        self.validators= list(replicas_ids.keys())
        self.window_size=5
        self.exclude_size=2
        self.reputation_leaders = dict()

        #=========Block Tree =================
        self.high_qc=QC(VoteInfo("id",-1,"id",-2,"test"),LedgerCommitInfo(None,""),["genesis"])
        self.high_commit_qc=QC(VoteInfo("id",-1,"id",-2,"test"),LedgerCommitInfo(None,""),["genesis"])
        self.pending_votes={}
        self.genesis_block=Block(Config.replica_id, -1, [], high_qc, "id")
        self.pending_block_tree= Tree(genesis_block) 

        #=================Safety=================
        self.__highest_vote_round=0
        self.__highest_qc_round=-1
        

        
    def set_variables():
        Config.replica_id = replica_id
        Config.n_replicas = n_replicas
        Config.n_faulty_replicas = n_faulty_replicas
        Config.window_size = self.window_size
        Config.network_delta = self.network_delta
        Config.public_key=public_key
        Config.private_key=private_key
        Config.replica_pub_keys=public_key
        Ledger.initialize_ledger()
    def run():
        debug('### start')
        run_done = False
        set_variables()
        while not run_done:
            round_done = False
            timer_duration = Pacemaker_get_round_timer(current_round)
            if await(round_done): pass
            elif timeout(timer_duration): 
                Pacemaker_local_timeout_round()
            
            # await(run_done)
        output('terminating')
        
    def receive(msg=("done",)):
        run_done=True

    # def receive(msg= ('request', p,client_id,m)):
    #     print(client_public_keys[client_id] )
    #     m=verify_decode(m,client_public_keys[client_id])
    #     print(("received request from",p,m))
       
    #     # print(("dsd",Temp2.get()))
    #     # print(private_key)
    #     send(("response",self,replica_id,sign_record(m,private_key)),to=p)
    #     debug('### request', p)

    # def receive(msg=("request",p,client_id,m)):
    #     m=verify_decode(m,client_public_keys[client_id])
    #     print((self,"received request from",p,m))
        
        # MemPool.push_transaction(m)

    def send_response(txn_id,m):
        client_id=txn_id[:txn_id.find('-')]
        send(("response",self,replica_id,sign_record(m,private_key)),to=client_ids[client_id])
    
    def send_msg_replica(id,msg_type,m):
        send((msg_type,self,replica_id,sign_record(m,private_key)),to=replicas_ids[id])

    def broadcast_msg(msg_type,m):
        send((msg_type,self,replica_id,sign_record(m,private_key)),to=set(replicas_ids.values()))

    
    def receive(msg=(msg_type,p,id,m)):
        
        # print(("====",sys.getsizeof((msg_type,p,id,m))))
        output(msg_type)
        if msg_type=="request":
            m=verify_decode(m,client_public_keys[id])
            Mempool_push_transaction(m)
        elif msg_type=="local_timeout":
            m=verify_decode(m,replica_public_keys[id])
            Pacemaker_local_timeout_round()
        elif msg_type=="proposal_message":
            m=verify_decode(m,replica_public_keys[id])
            process_proposal_msg(m)
        elif msg_type=="vote_message":
            m=verify_decode(m,replica_public_keys[id])
            process_vote_msg(m)
        elif msg_type=="timeout_message":
            m=verify_decode(m,replica_public_keys[id])
            process_timeout_msg(m)

    def process_certificate_qc(qc):
        
        BlockTree_process_qc(qc)
        
        LeaderElection_update_leaders(qc)
        Pacemaker_advance_round_qc(qc)

    def process_proposal_msg(P):
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        Pacemaker_advance_round_tc(P.last_round_tc)
        round = current_round
        leader = LeaderElection_get_leader(round)
        if P.block.round != round or P.sender != leader or P.block.author != leader:
            return 
        
        BlockTree_execute_and_insert(P.block)
        
        vote_msg = Safety_make_vote(P.block, P.last_round_tc)
        
        if vote_msg != None:
            send_msg_replica(LeaderElection_get_leader(round + 1),"vote_message",vote_msg)
        
           

    def process_timeout_msg(M):
        
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        Pacemaker_advance_round_tc(M.last_round_tc)
        tc = Pacemaker_process_remote_timeout(M)
        if tc is not None:
            Pacemaker_advance_round_tc(tc)
            process_new_round_event(tc)

    
    def process_vote_msg(M):
        qc = BlockTree_process_vote(M)
        
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)

    def process_new_round_event(last_tc):
        if replica_id==LeaderElection_get_leader(current_round):
            b=BlockTree_generate_block(Mempool_get_transactions(), current_round)
            broadcast_msg("proposal_message",ProposalMsg(b,last_tc,high_commit_qc) )
    
    #============Peacemaker==============
    def Pacemaker_get_round_timer(r): #need to implement this
        return 4*network_delta

    def Pacemaker_start_timer(new_round):
        # cls.stop_timer(cls.current_round) #need to implement stop_timer
        current_round = new_round
        round_done=True
    def Pacemaker_local_timeout_round():
        timeout_info = Safety_make_timeout(current_round, high_qc, last_round_tc)
        broadcast_msg("timeout_message",TimeoutMsg(timeout_info,last_round_tc,high_commit_qc))
     
    def Pacemaker_process_remote_timeout(tmo): #need to remove f
        
        tmo_info = tmo.tmo_info
    
        if tmo_info.round<current_round:
            return None

        pending_timeouts.setdefault(tmo_info.round,set())
        if tmo_info.sender not in [x.sender for x in pending_timeouts[tmo_info.round]]:
            
            pending_timeouts[tmo_info.round].add(tmo_info)

        if len([x.sender for x in pending_timeouts[tmo_info.round]]) == n_faulty_replicas+1:
            # stop_timer(current_round)
            round_done=True
            Pacemaker_local_timeout_round()
            
        if len([x.sender for x in pending_timeouts[tmo_info.round]]) == 2*n_faulty_replicas+1:
            return TC(tmo_info.round, [x.high_qc.vote_info.round for x in pending_timeouts[tmo_info.round]], [x.signature for x in pending_timeouts[tmo_info.round]])
        
        return None
    
   
    def Pacemaker_advance_round_tc(tc):
        if tc is None or tc.round<current_round:
            
            return False
        last_round_tc = tc
        Pacemaker_start_timer(tc.round+1)
        return True
    
    def Pacemaker_advance_round_qc( qc):
        
        if qc.vote_info.round < current_round:
            return False
        last_round_tc = None
        
        Pacemaker_start_timer(qc.vote_info.round+1)
        return True
    #==================MemPool==================
    def Mempool_get_transactions():
        if len(transaction_queue)==0:
            return [""]
        txn = transaction_queue.popleft()
        txn_id=txn[:txn.find(':')]
        req_cache.add(txn_id,"processing")
        return [txn]

   
    def Mempool_push_transaction(txn):
        txn_id = txn[:txn.find(':')]
        
        if(not req_cache.has(txn_id)):
            pending_transaction.add(txn_id)
            transaction_queue.append(txn)
            req_cache.add(txn_id,"In queue, not processed")
            
        else:
            send_response(txn_id,req_cache.get(txn_id,default=None))

  
    def Mempool_processed_txns(txns):
        for txn in txns:
            txn_id=txn[:txn.find(':')]
            req_cache.set(txn_id,"processed")
            pending_transaction.discard(txn_id)
            send_response(txn_id,req_cache.get(txn_id,default=None))

    #=============Leader election=============
    def LeaderElection_elect_reputation_leader(qc):
        
        active_validators = set()
        last_authors = set()
        current_qc = qc
        curr_window_size=0
        while(curr_window_size<window_size or len(last_authors)<exclude_size):
            current_block = Ledger.committed_block(current_qc.vote_info.parent_id)
            if current_block is None:
                break
            block_author = current_block.author
            if curr_window_size<window_size:
                active_validators = set.union(active_validators, current_qc.signatures.signers())
            if(len(last_authors) < exclude_size):
                last_authors.add(block_author)
            current_qc = current_block.qc
            curr_window_size+=1
        
        active_validators = active_validators-last_authors
        
        random.seed(qc.vote_info.round)
        
        if(len(active_validators)==0):
            return None
        
        return random.choice(active_validators)
        
    def LeaderElection_update_leaders(qc):
        extended_round = qc.vote_info.parent_round
        qc_round = qc.vote_info.round
        current_round = current_round
        if extended_round+1 == qc_round and qc_round+1==current_round:
            leader = LeaderElection_elect_reputation_leader(qc)
            if leader:
                reputation_leaders[current_round+1] = leader
        
    
    def LeaderElection_get_leader(round):
        if round in reputation_leaders:
            return reputation_leaders[round]
        
        return validators[math.floor(round/2)%len(validators)]

    
    #===========block tree ============
    def BlockTree_process_qc(qc):
        if qc.ledger_commit_info.commit_state_id is not None:
           
            Ledger.commit(pending_block_tree.get_block(qc.vote_info.parent_id))
            Mempool_processed_txns(pending_block_tree.get_block(qc.vote_info.parent_id).payload)
            pending_block_tree.prune(qc.vote_info.parent_id) #need to implement it
            high_commit_qc = max(qc.vote_info.round, high_commit_qc.vote_info.round)
        if qc.vote_info.round > high_qc.vote_info.round:
            high_qc = qc
        
       
        

    def BlockTree_execute_and_insert( b):
        Ledger.speculate(b.qc.vote_info.id,b)
        
        pending_block_tree.add(b) 

    def BlockTree_process_vote(v):
        BlockTree_process_qc(v.high_commit_qc)

        vote_idx = hash(v.ledger_commit_info)
        
        pending_votes.setdefault(vote_idx,set())
        pending_votes[vote_idx].add(v.signature)
        
        if len(pending_votes[vote_idx])==2*n_faulty_replicas+1:
            qc = QC(v.vote_info, v.ledger_commit_info, list(pending_votes[vote_idx]))
            
            return qc
        # print("=========================")
        return None

    def BlockTree_generate_block(txns, current_round):
        return Block(replica_id, current_round, txns, high_qc, hash((replica_id,current_round,txns,high_qc.vote_info.id,high_qc.signatures))) # need to implement it


    #======================safety==================
    def __Safety_increase_highest_vote_round(round):
        __highest_vote_round=max(round,__highest_vote_round)
    
    def __Safety_update_highest_qc_round(qc_round):
        __highest_qc_round=max(qc_round,__highest_qc_round)
    
    def __Safety_consecutive(block_round,round):
        return round+1==block_round
    
    def __Safety_safe_to_extend(block_round,qc_round,tc):
        return __Safety_consecutive(block_round,tc.round) and qc_round>=max(tc.tmo_high_qc_rounds)
    
    def __Safety_safe_to_vote(block_round,qc_round,tc):
        if block_round<=max(__highest_vote_round,qc_round):
            return False
        return __Safety_consecutive(block_round,qc_round) or __Safety_safe_to_extend(block_round,qc_round,tc)
    
    def __Safety_safe_to_timeout(round,qc_round,tc):
        if qc_round<__highest_qc_round or round<=max(__highest_vote_round-1,qc_round):
            return False
        return __Safety_consecutive(round,qc_round) or __Safety_consecutive(round,tc.round)
    
    def __Safety_commit_state_id_candidate(block_round,qc):
        if __Safety_consecutive(block_round,qc.vote_info.round):
            return Ledger.pending_state(qc.vote_info.id)
        else:
            return None
    
    def __Safety_valid_signatures(sig_list):
        return True
    
    def Safety_make_vote(b,last_tc):
        qc_round=b.qc.vote_info.round
        if __Safety_valid_signatures((b,last_tc)) and __Safety_safe_to_vote(b.round,qc_round,last_tc):
            __Safety_update_highest_qc_round(qc_round)
            __Safety_increase_highest_vote_round(b.round)
            vote_info=VoteInfo(id=b.id,round=b.round,parent_id=b.qc.vote_info.id,parent_round=qc_round,state=Ledger.pending_state(b.id))
            ledger_commit_info=LedgerCommitInfo(commit_state_id=__Safety_commit_state_id_candidate(b.round,b.qc),vote_info_hash=hash(vote_info))
            return VoteMsg(vote_info,ledger_commit_info,high_commit_qc)
        return None
    
    def Safety_make_timeout(round,high_qc,last_tc):
        qc_round=high_qc.vote_info.round
        if __Safety_valid_signatures((high_qc,last_tc)) and __Safety_safe_to_timeout(round,qc_round,last_tc):
            __Safety_increase_highest_vote_round(round)
            return TimeoutInfo(round,high_qc)
        return None

class VoteInfo:
    def __init__(self, id, round, parent_id, parent_round, state):
        self.id = id
        self.round = round
        self.parent_id = parent_id
        self.parent_round = parent_round
        self.state = state
    
class LedgerCommitInfo:
    def __init__(self, commit_state_id, vote_info_hash):
        self.commit_state_id = commit_state_id
        self.vote_info_hash = vote_info_hash
    
    def to_string(self):
        return "" + self.commit_state_id + self.vote_info_hash

class VoteMsg:
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc): #need to update object variables
        self.vote_info = vote_info
        self.ledger_commit_info= ledger_commit_info
        self.high_commit_qc = high_commit_qc
        self.sender = Config.replica_id
        self.signature = sign_record(self.ledger_commit_info,Config.private_key).decode("utf-8") 

class QC:
    def __init__(self, vote_info, ledger_commit_info, signatures): #need to update object variables
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.signatures = signatures
        self.author = Config.replica_id
        
        self.author_signature = sign_record(self.signatures,Config.private_key).decode("utf-8") 
        

class Block:
    def __init__(self, author, round, payload, qc, id):
        self.author = author
        self.round = round
        self.payload = payload
        self.qc = qc
        self.id = id


    # def to_string(self):
    #     return hash("".join(self.vote_info).join(self.ledger_commit_info.to_string()).join(self.signatures).join(self.author).join(self.author_signature))

        
