class EventLoop():

    def setup():

    def run():

    def start_event_processing(M):


    def process_certificate_qc(qc):
        BlockTree.process_qc(qc)
        LeaderElection.update_leaders(qc)
        Pacemaker.advance_round_qc(qc)

    def process_proposal_msg(P):
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        Pacemaker.advance_round_tc(P.last_round_tc)
        round = Pacemaker.current_round
        leader = LeaderElection.get_leader(round)
        if P.block.round != round or P.sender != leader or P.block.author != leader:
            return 
        BlockTree.execute_and_insert(P)
        vote_msg = Safety.make_vote(P.block, P.last_round_tc)
        if vote_msg != None:
           #send_vote msg to LeaderElection.get leader(current round + 1)

    def process_timeout_msg(M):
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        Pacemaker.advance_round_tc(M.last_round_tc)
        tc = Pacemaker.process_remote_timeout(M)
        if tc != None:
            Pacemaker.advance_round_tc(tc)
            Pacemaker.new_round_event(tc)

    
    def process_vote_msg(M):
        qc = BlockTree.process_vote(M)
        if qc!=None:
            process_certificate_qc(qc)
            process_new_round_event(None)

    def process_new_round_event(last_tc):
        if u==LeaderElection.get_leader(Pacemaker.current_round):
            b=BlockTree.generate_block(MemPool.get_transactions(), Pacemaker.current_round)
        #broadcast