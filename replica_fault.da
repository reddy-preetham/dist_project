from replica import Replica
from collections import namedtuple
import random
from enum import Enum
import logging


class MsgType(Enum):
    proposal_message = 1
    timeout_message = 2
    vote_message = 3
    response = 4
    wildcard = 5


class FailType(Enum):
    MsgLoss = 1
    Delay = 2
    SetAttr = 3


config(channel='reliable')


class ReplicaFI(process, Replica):

    def setup(replica_id: str, replicas_ids: dict, client_ids: dict, private_key: str, public_key: str, replica_public_keys: dict, client_public_keys: dict,
              n_faulty_replicas: int, rand_seed: int, network_delta: float, window_size: int, exclude_size: int, is_faulty: bool):
        is_faulty = True
        super().setup(replica_id, replicas_ids, client_ids, private_key, public_key,
                      replica_public_keys, client_public_keys, n_faulty_replicas, rand_seed, network_delta, window_size, exclude_size, is_faulty)
        self.FailureConfig = namedtuple(
            'FailureConfig', ['failures', 'seed'], defaults=[None, None])
        self.Failure = namedtuple('Failure', [
                                  'src', 'dest', 'msg_type', 'round', 'prob', 'fail_type', 'val', 'attr'], defaults=[None]*8)
        # failure config to set different failures
        self.failure_config = FailureConfig(failures=[Failure(src='_', dest='leader', msg_type=MsgType.vote_message, round=1, prob=1, fail_type=FailType.Delay, val=0.1),
                                            Failure(src="replica_2", dest='_', msg_type=MsgType.wildcard, round=3, prob=0.5, fail_type=FailType.MsgLoss),
                                            Failure(src='_', dest='_', msg_type=MsgType.vote_message, round=3, prob=0.5, fail_type=FailType.SetAttr, val=5, attr='highest_vote_round'),
                                            Failure(src="leader", dest='_', msg_type=MsgType.vote_message, round=-1, prob=0.5, fail_type=FailType.MsgLoss),
                                            Failure(src="_", dest='_', msg_type=MsgType.wildcard, round=3, prob=0.5, fail_type=FailType.SetAttr, val=1, attr='current_round')], seed=99)
        random.seed(self.failure_config.seed)

    def send(m, to):

        msg_type, _, replica_id, _, msg = m

        for i, failure in enumerate(failure_config.failures):
            src = ""
            dest = replicas_ids.get(failure.dest, "_")
            if(failure.src == 'leader'):
                src = LeaderElection_get_leader(failure.round)

            if(failure.dest == 'leader'):
                dest = replicas_ids[LeaderElection_get_leader(failure.round)]
            # check if msg info is matching failure config
            if (src == replica_id or src == "_") and (dest == "_" or dest in to) and (failure.msg_type == MsgType[msg_type] or failure.msg_type == MsgType.wildcard) and random.uniform(0.0, 1.0) >= failure.prob and (failure.round==-1 or current_round == failure.round):
                # failure triggered
                attr = failure.attr
                value = failure.val
                fail_type = failure.fail_type
                logging.info(failure)
                if fail_type == FailType.Delay:
                    await(timeout(value))
                elif fail_type == FailType.SetAttr:
                    setattr(attr, value)
                elif fail_type == FailType.MsgLoss:
                    return

        super().send(m, to)
